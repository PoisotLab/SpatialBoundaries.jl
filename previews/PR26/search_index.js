var documenterSearchIndex = {"docs":
[{"location":"vignettes/introduction/","page":"Introduction","title":"Introduction","text":"EditURL = \"https://github.com/EcoJulia/SpatialBoundaries.jl/blob/master/docs/src/vignettes/introduction.jl\"","category":"page"},{"location":"vignettes/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"vignettes/introduction/","page":"Introduction","title":"Introduction","text":"In this example, we will see how the SpatialBoundaries.jl package works, by taking a random mid-point displacement landscape, and measuring its rate and direction of change.","category":"page"},{"location":"vignettes/introduction/","page":"Introduction","title":"Introduction","text":"using SpatialBoundaries\nusing NeutralLandscapes\nusing StatsPlots","category":"page"},{"location":"vignettes/introduction/","page":"Introduction","title":"Introduction","text":"We will set a few options for the default plots:","category":"page"},{"location":"vignettes/introduction/","page":"Introduction","title":"Introduction","text":"default(; dpi=500, size=(600, 600), aspectratio=1, c=:davos, frame=:box)","category":"page"},{"location":"vignettes/introduction/","page":"Introduction","title":"Introduction","text":"The landscape generation is done using the NeutralLandscapes package, and we will pick a 500x500 grid:","category":"page"},{"location":"vignettes/introduction/","page":"Introduction","title":"Introduction","text":"landscape_size = (500, 500)\nlandscape = rand(MidpointDisplacement(0.75), landscape_size...)","category":"page"},{"location":"vignettes/introduction/","page":"Introduction","title":"Introduction","text":"By default, lattice wombling will assume that the cells have the same size, which is 1/n (where n is the number of cells on each side), but  you can specify your own x and y arguments.","category":"page"},{"location":"vignettes/introduction/","page":"Introduction","title":"Introduction","text":"We can take a quick peek at the landscape:","category":"page"},{"location":"vignettes/introduction/","page":"Introduction","title":"Introduction","text":"heatmap(landscape)","category":"page"},{"location":"vignettes/introduction/","page":"Introduction","title":"Introduction","text":"Getting the lattice wombling is done with","category":"page"},{"location":"vignettes/introduction/","page":"Introduction","title":"Introduction","text":"W = wombling(landscape);\nnothing #hide","category":"page"},{"location":"vignettes/introduction/","page":"Introduction","title":"Introduction","text":"The resulting LatticeWomble object has fields for the rate of change (m), the direction of change in degrees (θ), and the values of the centers of the cells at x and y (note that the grid of rates of change is one cell smaller than the original grid!).","category":"page"},{"location":"vignettes/introduction/","page":"Introduction","title":"Introduction","text":"Let's have a look at the rate of change:","category":"page"},{"location":"vignettes/introduction/","page":"Introduction","title":"Introduction","text":"heatmap(W.m, c=:PuOr, clim=(-1.,1.).*maximum(abs.(extrema(W.m))))","category":"page"},{"location":"vignettes/introduction/","page":"Introduction","title":"Introduction","text":"The direction of change is also given, and is expressed a wind direction; for instance, an angle of 180° means that the value is smaller in the South, and larger in the North:","category":"page"},{"location":"vignettes/introduction/","page":"Introduction","title":"Introduction","text":"heatmap(W.θ, clim=(0., 360.))","category":"page"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"EditURL = \"https://github.com/EcoJulia/SpatialBoundaries.jl/blob/master/docs/src/vignettes/simplesdmlayers.jl\"","category":"page"},{"location":"vignettes/simplesdmlayers/#Integration-with-SimpleSDMLayers","page":"SDM Layers","title":"Integration with SimpleSDMLayers","text":"","category":"section"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"The SpatialBoundaries package works really well with SimpleSDMLayers, so that you can (i) apply wombling and boundaries finding to a SimpleSDMLayer object, and (ii) convert the output of a Womble object to a pair of SimpleSDMLayer corresponding to the rate and direction of change.","category":"page"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"using SimpleSDMLayers\nusing SpatialBoundaries\nusing StatsPlots","category":"page"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"Note that the warning about dependencies is a side-effect of loading some functionalities for SimpleSDMLayers as part of SpatialBoundaries, and can safely be ignored.","category":"page"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"In this example, we will look at temperature data over Noth America, and measure the rate of change, as well as the direction of it. These data are extracted from the WorldClim database.","category":"page"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"temperature = SimpleSDMPredictor(\n    WorldClim, BioClim, 1; left=-130.0, right=-65.0, bottom=5.0, top=65.0\n)","category":"page"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"We can have a look at this layer, after setting a few defaults:","category":"page"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"default(; dpi=500, size=(600, 600), aspectratio=1, c=:davos, frame=:box)\nplot(temperature)","category":"page"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"There is an overload of the wombling method for SDM layers, so we can call it directly – this method might result in a bit more memory usage than expected, as it requires to transform the nothing values into NaNs, which in turn might require to convert the inner elements of the layer grid.","category":"page"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"W = wombling(temperature)","category":"page"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"By default, this returns a LatticeWomble. Let's look at the direction of change – mapping this information is difficult, so we will focus on the","category":"page"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"stephist(\n    deg2rad.(sort(vec(W.θ)));\n    proj=:polar,\n    lab=\"\",\n    c=:teal,\n    fill=(0, 0.2, :teal),\n    nbins=100,\n)","category":"page"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"The values for the direction of change are concentrated around 180° - note that the direction of change is reported as a wind direction, meaning that values tend to increase on a south-north axis.","category":"page"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"We can also map the rate of change. This is far easier to do with a proper SDM layer, so we will convert the wombling output:","category":"page"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"Lr, Ld = SimpleSDMPredictor(W)","category":"page"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"Note that we do not use convert here, because this call returns two layers in a tuple – this is a slight deviation from what we expect with SimpleSDMLayers, but it makes the code a little easier to write, and so is considered an acceptable trade-off.","category":"page"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"plot(Lr)","category":"page"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"With the Ld layer storing the direction of change, we can do a map - the main issue with mapping directions is colors, which need to have the same begin and endpoint, while remaining accessible to people with color vision defficiencies. Cyclic color schemes work for this purpose:","category":"page"},{"location":"vignettes/simplesdmlayers/","page":"SDM Layers","title":"SDM Layers","text":"plot(Ld, c=:romaO, clim=(0, 360))","category":"page"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"EditURL = \"https://github.com/EcoJulia/SpatialBoundaries.jl/blob/master/docs/src/vignettes/boundaries.jl\"","category":"page"},{"location":"vignettes/boundaries/#Finding-boundaries","page":"Finding boundaries","title":"Finding boundaries","text":"","category":"section"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"The output of a wombling operation can be used to pick boundaries, i.e. areas where the values on the grid transition sharply. We will illustrate this with a simple example of a three-patch landscape.","category":"page"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"using SpatialBoundaries\nusing StatsPlots\ndefault(; dpi=500, size=(600, 600), aspectratio=1, c=:batlow, frame=:box)","category":"page"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"Let's create a landscape with two values:","category":"page"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"A = rand(Float64, 200, 150);\nA[1:80, 1:85] .+= 5.0;\nA[110:end, 130:end] .+= 3.0;\nnothing #hide","category":"page"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"We can check out what this patch looks likes:","category":"page"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"heatmap(A)","category":"page"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"We can apply a wobling to this landscape, assuming that all cells have the same size:","category":"page"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"W = wombling(A);\nnothing #hide","category":"page"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"Let's look at the rate of change:","category":"page"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"heatmap(W.m; c=:nuuk)","category":"page"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"Picking the boundaries is done by passing the wombling output to the boundaries function, with a specific threshold giving the proportion of points that should be retained as part of the boundaries. Checking what the effect of this threshold is would be a good idea:","category":"page"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"thresholds = LinRange(0.0, 0.2, 200)\npatches = [length(boundaries(W; threshold=t)) for t in thresholds]\n\nplot(thresholds, log1p.(patches), aspectratio=:none)\nxaxis!(\"Threshold\", (0., 0.2))\nyaxis!(\"log(boundary patches + 1)\", (0., 9.))","category":"page"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"Let's eyeball this as a 0.01, and see how the patches are distributed.","category":"page"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"Another way we can look at the boundaries is to see when a patch is considered to be a boundary. To do so we will create an empty matrix, and fill each position with the lowest threshold at which it is considered to be a boundary:","category":"page"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"b = similar(W.m)\n\nfor t in reverse(LinRange(0.0, 1.0, 200))\n    b[boundaries(W; threshold=t)] .= t\nend\n\nheatmap(b, c=:tofino, clim=(0,1))","category":"page"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"This also suggests that we will get well delineated patches for low values of the threshold.","category":"page"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"B = boundaries(W; threshold=0.01);\n\nheatmap(A)\nscatter!([(reverse(x.I)) for x in B], leg=false, msw=0, c=:white)","category":"page"},{"location":"vignettes/boundaries/","page":"Finding boundaries","title":"Finding boundaries","text":"We can see that the boundaries of the patches have been well identified!","category":"page"},{"location":"#SpatialBoundaries.jl","page":"Home","title":"SpatialBoundaries.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SpatialBoundaries.jl","category":"page"},{"location":"#Core-functions","page":"Home","title":"Core functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"wombling\nboundaries","category":"page"},{"location":"#SpatialBoundaries.wombling","page":"Home","title":"SpatialBoundaries.wombling","text":"wombling(x::Vector{T}, y::Vector{T}, z::Vector{T}) where {T<:Number}\n\nWrapper function that implements the triangulation wombling algorithm for points that are irregularly arranged in space.\n\n\n\n\n\nwombling(x::Vector{T}, y::Vector{T}, z::Matrix{T}) where {T<:Number}\n\nWrapper function that implements the lattice wombling algorithm for points that are regularly arranged in space. Note that the matrix is presented in a way that is flipped, i.e. the x coordinates corresponds to the rows, and the y coordinates correspond to the columns. If you want to think of x and y as geographic coordinates, y are the longitudes, and x are the latitudes. Using the bindings for SimpleSDMLayers, this conversion will be performed automatically.\n\n\n\n\n\nwombling(m::Matrix{T}) where {T<:Number}\n\nShortcut to womble a matrix (using lattice wombling) when no x and y positions are given - the cell size in each dimension is expected to be 1.\n\n\n\n\n\n","category":"function"},{"location":"#SpatialBoundaries.boundaries","page":"Home","title":"SpatialBoundaries.boundaries","text":"boundaries(W::TriangulationWomble{T}; threshold::T=0.1) where {T <: Number}\n\nExtracts candidate boundaries using calculated rates of change (M) on specified threshold. Default threshold is 10%, meaning that the top 10% of pixels are selected as part of the boundaries. This function returns a list of indices identifying which simplices are part of the boundaries.\n\n\n\n\n\nboundaries(W::LatticeWomble{T}; threshold::T=0.1) where {T<:Number}\n\nExtracts candidate boundaries using calculated rates of change (M) on specified threshold. Default threshold is 10%, meaning that the top 10% of pixels are selected as part of the boundaries. This function returns an array of Cartesian indices corresponding to the rate of change matrix, indicating which positions are part of the boundaries.\n\n\n\n\n\n","category":"function"},{"location":"#Types","page":"Home","title":"Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LatticeWomble\nTriangulationWomble\nWomble","category":"page"},{"location":"#SpatialBoundaries.LatticeWomble","page":"Home","title":"SpatialBoundaries.LatticeWomble","text":"LatticeWomble{T <: Number} <: Womble\n\nA set of data (and co-ordinates) that are regularly arranged in space are of type LatticeWomble after having been passed through wombling - the fields in this type are\n\nm, a matrix of rate of change at each (x,y) co-ordinate\nθ, a matrix of direction of change at each (x,y) co-ordinate\nx and y, the coordinates of the center of each cell\n\nNote that the type of x and y should be the same as the element type of m and θ, because these values are all used when calculating the rate of change.\n\n\n\n\n\n","category":"type"},{"location":"#SpatialBoundaries.TriangulationWomble","page":"Home","title":"SpatialBoundaries.TriangulationWomble","text":"TriangulationWomble{T <: Number} <: Womble\n\nA set of data (and co-ordinates) that are irregularly arranged in space are of type TriangulationWomble after having been passed through wombling - the fields in this type are\n\nm, a vector of rate of change at each (x,y) co-ordinate\nθ, a vector of direction of change at each (x,y) co-ordinate\nx and y, the coordinates of the barycenter of each triangle in the plan\n\nNote that the type of x and y should be the same as the element type of m and θ, because these values are all used when calculating the rate of change.\n\n\n\n\n\n","category":"type"},{"location":"#SpatialBoundaries.Womble","page":"Home","title":"SpatialBoundaries.Womble","text":"Womble\n\nThe Womble abstract type is a catch-all for specific wombling outputs.\n\n\n\n\n\n","category":"type"}]
}
